// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
    async getZakuState(): Promise<Result<ZakuState, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_zaku_state") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async createSpace(createSpaceDto: CreateSpaceDto): Promise<Result<SpaceReference, ZakuError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("create_space", { createSpaceDto }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async setActiveSpace(spaceReference: SpaceReference): Promise<Result<null, ZakuError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("set_active_space", { spaceReference }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async deleteSpace(spaceReference: SpaceReference): Promise<null> {
        return await TAURI_INVOKE("delete_space", { spaceReference });
    },
    async getSpaceref(path: string): Promise<Result<SpaceReference, ZakuError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_spaceref", { path }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async showMainWindow(): Promise<void> {
        await TAURI_INVOKE("show_main_window");
    },
    async openDirDialog(options: OpenDirDialogOpt | null): Promise<Result<string | null, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("open_dir_dialog", { options }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async isNotifEnabled(): Promise<Result<boolean, ZakuError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("is_notif_enabled") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async requestNotifAccess(): Promise<Result<boolean, ZakuError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("request_notif_access") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async dispatchNotif(options: DispatchNotificationOptions): Promise<Result<null, ZakuError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("dispatch_notif", { options }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async createCollection(
        createCollectionDto: CreateCollectionDto,
    ): Promise<Result<CreateNewCollection, ZakuError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("create_collection", { createCollectionDto }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async createReq(createReqDto: CreateRequestDto): Promise<Result<CreateNewRequest, ZakuError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("create_req", { createReqDto }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async persistToReqbuf(spaceAbspath: string, relpath: string, request: HttpReq): Promise<void> {
        await TAURI_INVOKE("persist_to_reqbuf", { spaceAbspath, relpath, request });
    },
    async writeReqbufToReqtoml(spaceAbspath: string, reqRelpath: string): Promise<void> {
        await TAURI_INVOKE("write_reqbuf_to_reqtoml", { spaceAbspath, reqRelpath });
    },
    async httpReq(req: HttpReq): Promise<Result<HttpRes, HttpErr>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("http_req", { req }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async moveTreeitem(moveTreeitemDto: MoveTreeItemDto): Promise<Result<null, ZakuError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("move_treeitem", { moveTreeitemDto }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
};

/** user-defined events **/

/** user-defined constants **/

/** user-defined types **/

export type Collection = { meta: CollectionMeta; requests: HttpReq[]; collections: Collection[] };
export type CollectionMeta = {
    dir_name: string;
    display_name: string | null;
    is_expanded: boolean;
};
export type CreateCollectionDto = { parent_relpath: string; relpath: string };
export type CreateNewCollection = { parent_relpath: string; relpath: string };
export type CreateNewRequest = { parent_relpath: string; relpath: string };
export type CreateRequestDto = { parent_relpath: string; relpath: string };
export type CreateSpaceDto = { name: string; location: string };
export type DispatchNotificationOptions = { title: string; body: string };
export type HttpErr = { message: string; code: number | null };
export type HttpReq = {
    meta: ReqMeta;
    config: ReqCfg;
    status: ReqStatus;
    response: HttpRes | null;
};
export type HttpRes = {
    status?: number;
    data: string;
    headers: [string, string][];
    cookies: SpaceCookie[];
    size_bytes?: number;
    elapsed_ms?: number;
};
export type MoveTreeItemDto = { src_relpath: string; dest_relpath: string };
export type OpenDirDialogOpt = { title: string | null };
export type ReqCfg = {
    method: string;
    url: ReqUrl;
    headers: [boolean, string, string][];
    parameters: [boolean, string, string][];
    content_type?: string;
    body?: string;
};
export type ReqMeta = { file_name: string; display_name: string; has_unsaved_changes: boolean };
export type ReqStatus = "Idle" | "Pending" | "Success" | "Error";
export type ReqUrl = {
    raw?: string;
    protocol?: string;
    host?: string;
    path?: string;
};
export type Space = {
    abspath: string;
    meta: SpaceMeta;
    root: Collection;
    cookies: Partial<{ [key in string]: SpaceCookie[] }>;
};
export type SpaceCookie = {
    name: string;
    value: string;
    domain: string;
    path: string;
    secure: boolean;
    http_only: boolean;
    same_site: string | null;
    expires: string | null;
};
export type SpaceMeta = { name: string };
export type SpaceReference = { path: string; name: string };
export type ZakuError = { error: string; message: string };
export type ZakuState = { active_space: Space | null; spacerefs: SpaceReference[] };

/** tauri-specta globals **/

import { invoke as TAURI_INVOKE, Channel as TAURI_CHANNEL } from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
    listen: (cb: TAURI_API_EVENT.EventCallback<T>) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
    once: (cb: TAURI_API_EVENT.EventCallback<T>) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
    emit: null extends T
        ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
        : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> = { status: "ok"; data: T } | { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(mappings: Record<keyof T, string>) {
    return new Proxy(
        {} as unknown as {
            [K in keyof T]: __EventObj__<T[K]> & {
                (handle: __WebviewWindow__): __EventObj__<T[K]>;
            };
        },
        {
            get: (_, event) => {
                const name = mappings[event as keyof T];

                return new Proxy((() => {}) as any, {
                    apply: (_, __, [window]: [__WebviewWindow__]) => ({
                        listen: (arg: any) => window.listen(name, arg),
                        once: (arg: any) => window.once(name, arg),
                        emit: (arg: any) => window.emit(name, arg),
                    }),
                    get: (_, command: keyof __EventObj__<any>) => {
                        switch (command) {
                            case "listen":
                                return (arg: any) => TAURI_API_EVENT.listen(name, arg);
                            case "once":
                                return (arg: any) => TAURI_API_EVENT.once(name, arg);
                            case "emit":
                                return (arg: any) => TAURI_API_EVENT.emit(name, arg);
                        }
                    },
                });
            },
        },
    );
}
