// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
    async getZakuState(): Promise<Result<ZakuState, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_zaku_state") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async createSpace(createSpaceDto: CreateSpaceDto): Promise<Result<SpaceReference, ZakuError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("create_space", { createSpaceDto }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async setActiveSpace(spaceReference: SpaceReference): Promise<Result<null, ZakuError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("set_active_space", { spaceReference }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async deleteSpace(spaceReference: SpaceReference): Promise<null> {
        return await TAURI_INVOKE("delete_space", { spaceReference });
    },
    async getSpaceReference(path: string): Promise<Result<SpaceReference, ZakuError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_space_reference", { path }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async showMainWindow(): Promise<void> {
        await TAURI_INVOKE("show_main_window");
    },
    async openDirDialog(options: OpenDirDialogOpt | null): Promise<Result<string | null, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("open_dir_dialog", { options }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async isNotificationPermissionGranted(): Promise<Result<boolean, ZakuError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("is_notification_permission_granted") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async requestNotificationPermission(): Promise<Result<boolean, ZakuError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("request_notification_permission") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async dispatchNotification(
        options: DispatchNotificationOptions,
    ): Promise<Result<null, ZakuError>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("dispatch_notification", { options }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async createCollection(
        createCollectionDto: CreateCollectionDto,
    ): Promise<Result<CreateNewCollection, ZakuError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("create_collection", { createCollectionDto }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async createRequest(
        createRequestDto: CreateRequestDto,
    ): Promise<Result<CreateNewRequest, ZakuError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("create_request", { createRequestDto }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async saveRequestToBuffer(
        absoluteSpacePath: string,
        relativePath: string,
        request: HttpReq,
    ): Promise<void> {
        await TAURI_INVOKE("save_request_to_buffer", { absoluteSpacePath, relativePath, request });
    },
    async writeBufferRequestToFs(
        absoluteSpacePath: string,
        requestRelativePath: string,
    ): Promise<void> {
        await TAURI_INVOKE("write_buffer_request_to_fs", {
            absoluteSpacePath,
            requestRelativePath,
        });
    },
    async httpReq(req: HttpReq): Promise<Result<HttpRes, HttpErr>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("http_req", { req }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    async moveTreeItem(moveTreeItemDto: MoveTreeItemDto): Promise<Result<null, ZakuError>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("move_tree_item", { moveTreeItemDto }),
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
};

/** user-defined events **/

/** user-defined constants **/

/** user-defined types **/

export type Collection = { meta: CollectionMeta; requests: HttpReq[]; collections: Collection[] };
export type CollectionMeta = {
    dir_name: string;
    display_name: string | null;
    is_expanded: boolean;
};
export type CreateCollectionDto = { parent_relative_path: string; relative_path: string };
export type CreateNewCollection = { parent_relative_path: string; relative_path: string };
export type CreateNewRequest = { parent_relative_path: string; relative_path: string };
export type CreateRequestDto = { parent_relative_path: string; relative_path: string };
export type CreateSpaceDto = { name: string; location: string };
export type DispatchNotificationOptions = { title: string; body: string };
export type HttpErr = { message: string; code: number | null };
export type HttpReq = {
    meta: ReqMeta;
    config: ReqCfg;
    response: HttpRes | null;
    status: ReqStatus;
};
export type HttpRes = {
    status?: number;
    data: string;
    headers?: [string, string][];
    cookies?: [string, string][];
    size_bytes?: number;
    elapsed_ms?: number;
};
export type MoveTreeItemDto = { source_relative_path: string; destination_relative_path: string };
export type OpenDirDialogOpt = { title: string | null };
export type ReqCfg = {
    method: string;
    url: ReqUrl;
    headers: [boolean, string, string][];
    parameters: [boolean, string, string][];
    content_type?: string;
    body?: string;
};
export type ReqMeta = { file_name: string; display_name: string; has_unsaved_changes: boolean };
export type ReqStatus = "Idle" | "Pending" | "Success" | "Error";
export type ReqUrl = {
    raw?: string;
    protocol?: string;
    host?: string;
    path?: string;
};
export type Space = { absolute_path: string; meta: SpaceMeta; root: Collection };
export type SpaceMeta = { name: string };
export type SpaceReference = { path: string; name: string };
export type ZakuError = { error: string; message: string };
export type ZakuState = { active_space: Space | null; space_references: SpaceReference[] };

/** tauri-specta globals **/

import { invoke as TAURI_INVOKE, Channel as TAURI_CHANNEL } from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
    listen: (cb: TAURI_API_EVENT.EventCallback<T>) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
    once: (cb: TAURI_API_EVENT.EventCallback<T>) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
    emit: null extends T
        ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
        : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> = { status: "ok"; data: T } | { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(mappings: Record<keyof T, string>) {
    return new Proxy(
        {} as unknown as {
            [K in keyof T]: __EventObj__<T[K]> & {
                (handle: __WebviewWindow__): __EventObj__<T[K]>;
            };
        },
        {
            get: (_, event) => {
                const name = mappings[event as keyof T];

                return new Proxy((() => {}) as any, {
                    apply: (_, __, [window]: [__WebviewWindow__]) => ({
                        listen: (arg: any) => window.listen(name, arg),
                        once: (arg: any) => window.once(name, arg),
                        emit: (arg: any) => window.emit(name, arg),
                    }),
                    get: (_, command: keyof __EventObj__<any>) => {
                        switch (command) {
                            case "listen":
                                return (arg: any) => TAURI_API_EVENT.listen(name, arg);
                            case "once":
                                return (arg: any) => TAURI_API_EVENT.once(name, arg);
                            case "emit":
                                return (arg: any) => TAURI_API_EVENT.emit(name, arg);
                        }
                    },
                });
            },
        },
    );
}
